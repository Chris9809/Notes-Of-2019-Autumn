

# 软件设计第一讲：笔记

> @Date:2019年08月26日
>
> @Author:YeLihu
>
> @Email:87160265@qq.com

***

[TOC]



## 课程介绍

> 课程时间：2019-08-26

==Q：软件设计和程序设计有什么不一样？==

==Q：软件包含什么==

**和其他课程的关系**

1. 需求：**前导课程**
2. 数据库：
   1. 数据库的类型是什么？
   2. 数据库的数据量有多大？需不需要分库分表的操作？
   3. 数据的更新频率是多大？
   4. 范式/性能？
3. 测试：**测试是保证软件质量的==重要环节==**
   1. 测试用例怎么设计？
   2. **测试的依据是分析的文档**
4. 构造和演化：**软件设计的后续课程**
   1. 编码，<u>单元测试，集成测试和性能测试</u>形成了软件的构造
   2. 设计模式？
5. 软工综合实践：第七个学期
6. 毕设：第八个学期



***

## 基本概念

### 软件体系结构出现的原因

- 上个世纪90年代，网络的发展，==Web Server==的出现导致。

- 软件具有**抽象**的特点，不像建筑工程等，只需做好设计，画好图纸即可。

> **什么是Web Server**？
>
> Web服务器可以解析HTTP协议。当Web服务器接收到一个HTTP请求(request)，会返回一个HTTP响应(response)。
>
> 例如送回一个HTML页面。为了处理一个请求(request)，Web服务器可以响应(response)一个静态页面或图片，进行页面跳转(redirect)，或者把动态响应的产生委托给一些其它的程序例如JSP(JavaServer 
> Pages)脚本，servlets，ASP(Active Server Pages)脚本，服务器端(server-side)JavaScript，或者一些其它的服务器端(server-side)技术。

***

#### 软件危机：

需求的时候讲过，软件危机发生的原因：<u>需求不明确，软件项目管理不当</u>、技术...

##### 原因

- 软件的规模越来越大，项目进度已经无法控制
- 成本(谁出钱？)
- 软件质量差

##### 如何解决

- 需求方面进行改革==(解决需求的问题)==
- 项目管理，引入体系结构==(解决规模的问题)==

> **维基百科**：[https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA](https://zh.wikipedia.org/wiki/软件危机)

***

### 体系结构的兴起

- 随着软件系统规模越来越复杂，整个系统的结构和规格说明显得越来越重要。
- 对于大规模的复杂软件系统来说，对**总体的系统结构**设计和规格说明比起**算法和数据结构**的选择==重要得多==。
- 对软件体系结构的研究将会成为提高软件生产率和解决软件**维护问题**的有效途径。(DevOPs、以产品管理为核心)
- 事实上，软件总是有体系结构的，**不存在没有体系结构的软件**。
- 软件体系结构虽起源于软件工程，但其形成同时借鉴了**计算机体系结构**和**网络体系结构**中很多宝贵的思想和方法，成为软件工程研究的重要分支



***

### 体系结构的定义

#### 从构成的角度

注重区分处理构件、数据构件和连接构件，这一方
法在其它的定义和方法中基本上得到保持

#### 从工程过程的角度

这一过程在的算法设计和数据结构设计之上

处理的是整体的结构，构件、协议...

> 爷问：什么是协议？
>
> 协议包含：
>
> - 数据格式
> - 数据顺序
>
> 一种关于内容和顺序的约定，比如我们要求数据接口的参数、返回值、取值范围等，这就是一个协议。

#### 从审视的视角

 体系结构是复杂的，我们怎么去观察体系结构呢？下面四个视角。

- 概念角度描述系统的==主要构件及它们之间的关系==；
- 模块角度包含功能分解与层次结构；
- 运行角度描述了一个系统的动态结构
- 代码角度描述了各种代码和库函数在开发环境中的组

#### 从重用的角度

代码重用的好处如下：

1. 提高效率
2. 节约时间（比如框架）。

软件体系结构级的重用意味着体系结构的决策能在具有相似需
求的多个系统中发生影响，这比代码级的重用要有更大的好处。

#### 从维护的角度

软件体系结构是一个程序／系统各构件的结构、它们之间的相互关系以及进行设计的原则和随时间演化的指导方针。

#### 从工程的作用

软件体系结构包括一个软件和系统构件、互联及约束的集合一个系统需求说明的集合





***

### 软件体系结构的意义

体系结构是风险承担者（Stick Holder）进行交流的手段

从对象的角度来看：软件 = 对象 + 消息

**软件体系结构，用户要参与评审(怎么参与评审？)**

- 软件体系结构代表了系统的公共的高层次的抽象
- 软件体系结构对项目最终的质量和使用有极大的影响



**软件体系结构的作用：**

1. 体系结构是早期设计决策的体现

2. 软件体系结构明确了对系统实现的约束条件

3. 软件体系结构影响了开发组织的组织结构

4. 软件体系结构制约着系统的质量属性

5. 通过研究软件体系结构可能预测软件的质量(预测每千行代码的数量...)

6. 软件体系结构使推理和控制更改更简单

7. 软件体系结构有助于循序渐进的原型设计(先做核心的功能)

8. 软件体系结构可以作为培训的基础(新的人员可以根据文档快速的了解)





***

### 软件体系结构的发展史

![image-20190828155521755](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190828155521755.png)

### 体系结构描述构造与表示

<u>描述体系结构的过程称为体系结构构造</u>

"==4+1=="模型包括

- 设计视图
- 进程视图
- 实现视图
- 部署视图
- 用例视图

IEEE于1995年成立了体系结构工作组，起草了体系结构描述框架标准IEEE P1471

> 这是一种严格的国际标准，不同于国际标准的还有组织标准和国家标准，行业标准和企业标准。比如TCP/IP和UML就是一种行业标准

### 体系结构分析、设计与验证

**验证**

<u>ATAM-Architecture Tradeoff Analysis Method</u>

上面这个是软件体系结构评审的标准。

### 基于体系结构的软件开发方法

引入体系结构之后，软件系统的开发过程变为==“问题定义—>软件需求—>软 件体系结构—>软件设计—>软件构造”== 

软件体系结构架起了软件需求与软件设计之间的一座桥梁 

在基于构件和基于体系结构的软件开发逐渐成为主流情况下，已经出现了基于==构件==的软件工程。 

> **什么是构件？**
>
> 构件类似于service，可以举例为第三方支付，地图等第三方接口。除了service，还可以通过网络协议等实现。



### 特定领域的体系结构框架

体系结构设计是可重用的，特定领域下，软件体系结构是相似的。

DSSA：面向某一个领域的体系结构。

***

### 本课程的体系结构

- 软件体系结构：体系结构是一种构件的层次化结构，包含构件之间的交互方式、 

  构件使用的数据结构

- 构件：指==语义完整==、语法正确和有可重用价值的软件单元。比如属性要定义取值类型，范围等、方法要指明参数和功能。

### 构件模型

面向构件的模型历史上有：CORBA,EJB（SUN公司的Enterprise Java Bean）,COM/COM+/DCOM。

但是他们彼此之间互不兼容，各家有各家的标准，所以并没有流行开来。他们被SOA取代。

> **SOA理解：**
>
> 把系统按照实际业务，拆分成独立部署的模块。
>
> 比如Web、Android、iOS三个端的网易云音乐都需要访问一个数据库来查询用户账号密码是否存在。
>
> 不使用SOA的思想，使用传统的解决方式是每个端都自己写一个查询的方法。
>
>  坏处是如果数据库变动，比如某一天username字段变成了xuehao（学号），那么三个端全部需要改各自的代码，并且三个段修改的逻辑和操作完全一样。
>
> 于是出现了这样的设计思想，搭建一个工程部署在一个服务器上，其余三个端（Web、Android、iOS）可以通过http或者基于socket的PRC调用来访问，获取JSON格式或者XML格式的数据。这个访问的端口暴露给这三个端，这种方式叫做"==服务=="。同理，其他场景的操作都可以这样形成服务。
>
> **优点是：**
>
> - 解耦
> - 当这个场景的业务突然出现高并发的时候，可以多提供几台服务器来提供服务。
> - 清楚的看到谁调用服务，调用热度…便于之后的优化
>
>  SOAP、REST、RPC就是根据这种设计模式构建出来的规范，其中SOAP通俗理解就是http+xml的形式，REST就是http+json的形式，RPC是基于socket的形式。CXF就是典型的SOAP/REST框架，dubbo就是典型的RPC框架，而SpringCloud就是遵守REST规范的生态系统。
>
> 上述文字参考和整理自CSDN一篇博文...

***

### 软件体系建模

**"4+1"模型-概述**

"==4+1=="模型包括

- 设计视图
- 进程视图
- 实现视图
- 部署视图
- 用例视图

#### "4+1"模型-逻辑视图

![image-20190902110306909](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190902110306909.png)

OS/CPU/网络等等都与软件的架构息息相关。

#### "4+1"模型-逻辑视图解析

与需求上相同的是，都是使用UML语言来描述，但是在设计中，不包括一些物理实体。

- 逻辑视图主要支持系统的功能需求，即系统提供给最终用户的服务。 
- 在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表 逻辑视图，用类图来描述逻辑视图 

#### "4+1"模型-开发视图解析

开发人员(程序员)使用

描述一个类的名称方法属性等。

开发视图当中是分层描述的(controller、service、dao…...)

#### "4+1"模型-进程视图描述

几个进程可能运行在不同的机器上。

比进程更小的单位是线程和协程，因为当前cpu是多核的，能够更好的提高并发的表现。

#### "4+1"模型-部署视图/物理视图

描述软件和硬件的配合

为了满足软件对于硬件的需要：

- 软件需要多少带宽？(网络)
- cpu需要多少核心的？需不需要集群？
- ...

#### "4+1"模型-用例视图(4+1模型中的1)

将需求中用例图的system打破，拆分和展开。 

### 体系结构设计过程

#### 目标和实施者

将逻辑模型转化为实现模型。

实施者是：==系统架构师==

##### 参与者

- 开发者(程序员、测试人员…...)
- 用户代表
- 硬件/网络架构师
- 安全架构师/咨询师、 
- 操作人员 

##### 过程

##### 主要输出

主要输出有如下几个文档

- 体系结构设计文档 (ADD-Architectural Design Document); 
- 详细设计阶段的软件项目管理计划 (SPMP/DD);
- 详细设计阶段的软件配置管理计划 (SCMP/DD);
- 详细设计阶段的软件验证与确认计划 (SVVP/DD);
- 详细设计阶段的软件质量保证计划 (SQAP/DD);
- 集成测试计划 (SVVP/IT).
- 进度报告和配置状态审计报告 



***

#### 体系结构设计的基本原则

**基本原则如下，后附解析(加粗)：**

- 考虑多种设计方案：

  需要考虑==平衡折中==的方案(投资/时间/领域是否成熟/团队的能力)*

- 设计应该可跟踪到需求模型

  设计一定是基于需求而不是想象！==跟踪矩阵==可以很好的解决这个问题*

- 设计应尽可能地重用设计经验：

  *为了提高质量和效率，既然可以重用，说明有了先前经验，质量上可以保证，重用能够节省时间。类似于需求的重用（<u>概念模型可以重用,用户、功能...</u>），设计也可以有重用(==体系结构风格style==、==设计模式DP==)。*

- 软件的结构应与问题域的结构相近。

  *比如教务系统的设计上，用户角色和岗位的设置就要==尽可能的和现实一样==。*

- 设计模型应该符合统一规范。

  *不同岗位、前端后端，都需要遵循一定的规范。*

- 设计不是编码，编码也不是设计。

  *设计中的伪码比C/Java…编程语言更加抽象，并且注重逻辑。*

- 对设计模型进行质量评审，而不是事后进行修改。

  *找bug效率最高的方式、质量的保证是——==评审==。评审可以分为结对编程和<u>正式评审</u>，这个环节发生在正式提交编译之前。*



> **如何将人工智能运用到软件工程？**
>
> 自动编码、项目管理





***

#### 软件体系结构风格

***

##### 软件体系结构风格的定义

- 描述**某一特定应用领域**中系统组织方式的**惯用模式**。 某一类特定的领域
- 体系结构风格定义了一个系统家族：即一个体系结构定义了：
  - **一个词汇表**：词汇表包含
    - **一些构件**：内存，数据库….
    - **<u>连接件类型</u>**：协议(HTTP/JDBC…)构件之间联系的方式。
  -  **一组约束**：这组约束指出系统 是如何将上面这些构件和连接件组合起来的。 
- 体系结构风格反映了领域中众多系统所共有的结构和语义特性，并指导 如何将各个模块和子系统有效地组织成一个完整的系统。 

***

##### 经典的软件体系结构风格

- 数据流风格:批处理序列;**管道**/过滤器**例子：Linux和Unix的非交互式系统，一个个命令按照输入的顺序执行。**
- 调用/返回风格:主程序/子程序;面向对象风格;**分层结构**。**对象→方法**
- 仓库风格:==数据库系统==;超文本系统;黑板系统。

***

**上面三种结构风格优缺点整理如下：**

|      | 数据流风格                                                   | 面向对象的体系                           | 仓库风格                                     |
| ---- | ------------------------------------------------------------ | ---------------------------------------- | -------------------------------------------- |
| 优点 | 重用、维护、并发性支持、大数据处理(数据的去杂、过滤、去噪等…使用流的方式会更好) | 交互性强，复用性好                       | 数据和事务的处理(数据的管理：增、删、查、改) |
| 缺点 | 没有交互、设计复杂                                           | 必须知道谁(对象)提供服务(函数)，灵活性差 | 单一，优点也是缺点                           |



***

###### 管道和过滤器

![image-20190904152842976](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904152842976.png)

**管道和过滤器的优点**

适合大数据处理，数据的去杂去噪过滤等操作。

**管道和过滤器的缺点**

没有交互

***

###### 分层系统

> 计算机网络就是分层的体现，物理层/网络层/应用层/…...

**分层系统的优点**：

将大的系统降低复杂度。

可以协作、便于维护、便于重用。避免竞争。、

**分层系统的缺点**：

**实时性、性能要求较高的系统支持较差**

本来是直接简单的操作，现在需要在整个系统中层层传递，势必造成性能的下降，同时也加大的开发的复杂度。

***

###### 仓库系统

- 数据库
- 内存方式：Html5中的内存数据库、session、indexDB…...



***

###### C/S架构

**主要有三个组成部分：**

1. 数据库服务器
2. 客户应用程序
3. 网络

***

**CS发展历史**

![image-20190904154900108](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904154900108.png)

***

**C/S风格的优点**

- 数据管理和应用分开，安全性高。
- 数据的处理效率高，局域网内效果明显。
- 对于整个计算机系统的扩充较为灵活

***

**C/S风格的缺点**

- 开发成本较高
- 客户端设计复杂
- 移植性、可维护性较差
- 软件升级困难
- 新技术不能轻易应用



***

###### 三层CS架构——面向构件的软件开发

解决CS架构的缺点，远程调用方法。这种过程属于实例与实例之间的调用。

出现了应用服务器、对应的软件体系结构是三次C/S风格

![image-20190904160424981](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904160424981.png)

***

![image-20190904160617897](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904160617897.png)

***

**C/S结构的优点**

- 可维护（比如界面修改）、可升级(比如服务器扩容、改集群)
- 硬件上可以纵向升级(加内存...)
- 编程语言上自由选择，只要服从一定的协议即可。
- 数据展示层和数据层分开，保证了安全性。



**C/S结构的缺点**

- 通信效率不高(分层结构的通病，比如计算机网络7层/5层架构)
- 通信技术的选型(通信方法/通信频度/数据量)麻烦，设计和开发时间长。



> 2019年09月09日
>
> 爷问：**框架（Framework）**和**库（Library）**有什么区别
>
> **框架：**
>
> 调用我们写的callback，函数的参数往往可以是一个回调函数，需要我们自定义并传入。也就是说，我们的代码按照别人的规则去写，这里也有IOC（控制反转）的思想
>
> **库：**
>
> 单纯的被我们调用。
>
> 参考资料：https://blog.C/Sdn.net/weixin_41146340/article/details/79385244



***

###### B/S架构

B/S架构本质上还是C/S架构，只不过browser(浏览器）是一种特殊的client（客户端）。

三层BS架构图示如下：

**![image-20190909102716419](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909102716419.png)**



***

**B/S架构的优点：**

- 安装、维护、升级（运行时）方便（云服务使得租用服务器变得更加方便）
- 只要支持上层TCP/IP的协议，不同的服务器类型和底层网络技术都能支持网页浏览。

> 底层网络技术有哪些？
>
> 网络底层技术是指接入网络所必需、必要的、最基本需要满足的条件的技术。
> 网络底层技术包括
>
> 1. 以太网技术（局域网）
> 2. 其他局域网技术
> 3. 光纤分布式数据接口
> 4. 其他诸如路由器、MODE等数据交换及辅助技术



**B/S架构的缺点**

- **安全性（主机安全、网络安全、应用安全）不易控制**，因为建立在一个**开放的协议**之上。
- 数据查询速度较慢，**协议更多**，现在出现了一些在线处理数据的技术
- 数据动态交互性较差



***

**B/S架构与C/S架构的优缺点对比：**

| **C/S**            | B/S                |
| ------------------ | ------------------ |
| 应用部署在客户端上 | 应用部署在服务器上 |
| 不利于维护和升级   | 升级和维护方便     |





***

##### 接口定义语言

**CORBA定义：**

CORBA 通用对象请求代理体系结构 *(Common Object Request Broker Architecture)* 由OMG组织制定的一种标准面向对象应用程序**体系规范**。



**CORBA的特点：**

- 引入中间件作为事务代理，完成C端向S端提出的服务请求
- C端和S端完全分开
- 软总线机制，分布式系统中的任何一段不被编程语言限制，彼此之间只要符合接口规范定义即可通信。CORBA利用IDL*（Interface Defination Language）*统一地描述服务器，为C端提供了语言的独立性。
- 使用面向对象软件实现方法，内部完整封装，保留对象方法的对外接口。*CORBA*中的*IDL*接口定义语言用来描述接口而不涉及具体实现。

> 中间件：
>
> 中间件是一种系统软件和服务程序，实现两个不同的应用程序在不同的OS环境下，通过中间件可以交换信息；应用程序有能力能够运行在多平台(OS环境)

***

###### CORBA结构图

![image-20190909105622978](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909105622978.png)





***

##### 异构风格

同个系统下，有时面对来自不同环境的操作，以及不同的业务情况下会混合搭配使用不同的软件体系结构。是因为：

- 扬长避短
- 随着时间的改变，变动是绝对的
- 历史遗留代码，不再重写



###### 内外有别模型

![image-20190909110033888](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909110033888.png)



**解释：**

内部访问用C/S架构，外部访问用B/S架构

***

###### 查改有别模型

![image-20190909110205829](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909110205829.png)

**解释：**

查询数据用B/S架构，修改数据用C/S架构





***

### 面向过程的设计

#### 基本概念

##### 抽象

将事务内在、本质的东西集中**概括**，差异和细节。

- 高层抽象与问题域有关

比如校医院系统的人物抽象（血型、体重、病史...）和教务管理系统的人物抽象（学号、年级、挂科数...）是不一样的

- 底层抽象与计算有关

存储一系列同等类型的实例的集合。

***

##### 细化

<u>集中精力解决主要问题</u>，**推迟**对细节的考虑

**特点：**

特点逐渐增加，自顶向下的策略。

**Miller（7±2）法则：**

人只能把注意力集中在5-9个知识块之上。

**意思是：**类的方法或结构的层次我们都只能把它分为5-9个/层



***

#### 模块化设计

**整个系统分为若干模块**，每个模块实现一个功能，为了实现**==降低复杂问题的难度==**。

实践发现，问题分开解决比问题一起解决的复杂度小。但是模块数量多了之后，模块和模块之间的**通信接口的的成本会上升**，盲目增加模块数量是不理智的。



![image-20190909112504751](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909112504751.png)



***

**模块化的好处**

**模块化的好处如下：**

- 可读性好*导致了第2点和第3点的产生*
- debug和测试容易
- 整体的可修改性优
- 人员分工方便、多人协作
- 代码重用性好



> 那么，模块化好不好的指标是什么？
>
> 模块独立性来衡量

***

#### 模块独立性

**模块的独立性要求模块必须**

- 联系最少
- 接口简单：参数数量小于等于三、 参数的类型尽可能的基本

**模块的独立性要求我们必须设计出高内聚低耦合的模块**



模块的独立性的衡量/组成包括模块的内聚和耦合

***

##### 模块的内聚

模块内部之间的联系越紧密，模块的独立性越高。

![image-20190911150342015](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190911150342015.png)

由图可见，**模块的独立性和内聚程度呈现正相关的关系**。



内聚包含以下七个部分

***

###### 逻辑性内聚

几个逻辑上相似的代码糅合在一起，使用一个标志(flag变量)去决定调用哪一个部分的代码。这样的内聚叫做逻辑性内聚。

**缺点**

- 不易修改
- 产生耦合
- 加载效率低

工厂类不属于这种内聚，工厂类



***

###### 偶然性内聚

将结构和功能相似的代码，合成一个模块。

这种内聚的等级最低，**特点如下：**

1. 内聚程度底下导致模块独立性差
2. 出错率最高



***

###### 时间性内聚

一个模块将需要在==同一时间完成的多种任务合并在一起执行==，这样的代码叫做时间性内聚。

比如在一个程序初始化<u>不仅</u>需要加载类库<u>还要</u>进行读取文件进行I/O等….，把上面这两种代码的执行**糅合**在一个模块中的这种内聚，就叫做时间性内聚。

<u>它和对象的生命周期（lifecycle，比如存在在安卓的activity里）的存在不属于一个性质，JVM里面引入生命周期机制为了GC（垃圾回收）收回对象占用的系统资源。</u>



***

###### 过程性内聚

这一个模块只是单纯的将==彼此之间有先后顺序、下层需要上层代码提供处理结果==的代码合成一个模块。

函数的递归当然不是过程性内聚。



***

###### 通信性内聚

这一个模块的相似点只是==共用相同的输入或者拥有相似的输出==。这样执行这些糅合在一起的代码的时候，传一个共用的参数即可。返回值也同理。



***

###### 顺序性内聚

假如这==一个程序分为几个部分==，每一个部分都围绕着一个功能服务，比如处理上传的文件或者处理字符串的格式等等…。并且==这些部分必须按照顺序来执行==，那么这样的内聚方式叫做顺序性内聚。

**顺序性内聚和时间性内聚的不同之处**

时间性内聚模块里的功能并不是围绕一个相同的功能服务的：

**设想一个场景**：

字符串解码之后需要把字符串交给别的函数形成txt文件输出。（这样的场景就是顺序性内聚）

但是时间性内聚，模块中的代码的场景各不相同。你可以做文件的IO，我可以初始化导入的类库….





***

###### 功能性内聚

==一整个模块的代码都是为了一个事务场景/具体功能服务的，模块之间的所有部分不能分割。==

比如Spring Framework自带封装好的StringUtils类，我们可以使用这个模块处理针对字符串的所有事务。

同理，大部分封装完备的一个util类都可以叫做功能性内聚。

**功能性内聚和顺序性内聚的区别**

功能性内聚为了完成一个完整的功能，顺序性内聚可以看做功能性内聚中的一部分。<u>(个人理解)</u>

功能性内聚内聚程度**最强**。



****

###### 百度百科上的解释

内聚性是一种非量化的量测，可利用评量规准来确认待确认源代码的内聚性的分类。内聚性的分类如下，由低到高排列：

- 偶然内聚性（Coincidental cohesion，最低）偶然内聚性是指模块中的机能只是刚好放在一起，模块中各机能之间唯一的关系是其位在同一个模块中**（例如：“工具”模块）**。

> 这里和大爷矛盾，存疑，不清楚这个工具模块是不是util类

- 逻辑内聚性（Logical cohesion）逻辑内聚性是只要机能只要在逻辑上分为同一类，不论各机能的本质是否有很大差异，就将这些机能放在同一模块中（例如将所有的鼠标和键盘都放在输入处理副程序中）。
- 时间性内聚性（Temporal cohesion）时间性内聚性是指将相近时间点运行的程序，放在同一个模块中（例如在捕捉到一个异常后调用一函数，在函数中关闭已打开的文件、产生错误日志、并告知用户）。
- 程序内聚性（Procedural cohesion）程序内聚性是指依一组会依照固定顺序运行的程序放在同一个模块中（例如一个函数检查文件的权限，之后打开文件）。
- 联络内聚性（Communicational cohesion）联络内聚性是指模块中的机能因为处理相同的数据，因此放在同一个模块中（例如一个模块中的许多机能都访问同一个记录）。
- 依序内聚性（Sequential cohesion）依序内聚性是指模块中的各机能彼此的输入及输出数据相关，一模块的输出数据是另一个模块的输入，类似工厂的生产线（例如一个模块先读取文件中的数据，之后再处理数据）。
- 功能内聚性（Functional cohesion，最高）功能内聚性是指模块中的各机能是因为它们都对模块中单一明确定义的任务有贡献（例如XML字符串的词法分析）。



***

##### 模块的耦合

###### 非直接耦合

两个模块之间没有任何关系，他们之间通过**主函数调用**。

比如main函数调用函数func1和函数func2来分别完成计算1+1和在屏幕上画画的操作。



***

###### 数据耦合

模块之间通过**基本数据结构**来通信，在高级语言中属于**值传递**而不是引用。

比如 `return int/boolean  `



***

###### 特征耦合

两个模块之间传递的数据结果或者对象，也就是上面说的**引用传递**（地址传递）java中的对象就是地址传递。



**怎么体现增加的耦合性呢？**

*比如我想使用你传给我的一个object，我必须清楚这个对象的类型、属性、方法…..给我添加了"有义务去了解这个对象"的麻烦，降低了可理解性。*



***

###### 控制耦合

通过一个**flag**变量（**控制变量**）来调用另外一个模块

> 和逻辑性内聚是对应的

**怎么体现增加的耦合性呢？**

*相比上面的特征耦合*，我现在甚至需要知道你这个函数里面有什么内容了，我还得记住这个函数，什么变量能调用出什么效果来。



***

###### 外部耦合

一组模块访问一个**全局变量**



***

###### 公共耦合

一组模块访问一个公共数据结构

> c语言的结构体

**公共耦合会造成**

- 存取控制不方便
- 可维护性差
- 可理解性差，*需要"我"去搞懂哪些数据被哪些模块使用*



***

###### 内容耦合

当：

1. 一个模块可以**直接访问**另外一个模块内部
2. 一个模块通过**不正常入口**进入另外模块**内部**
3. 一个模块**多个入口**

这三种情况出现的时候，内容耦合产生。

> 举例：
> C语言的goto语句
>
> 汇编中的jump



这种耦合程度**最强**，维护起来最麻烦。



***

#### 软件设计模型的描述

描述方法可分为两类符号：

#### 结构视图

- 文本、**形式化语言（离散数学中的逻辑、集合、代数）**、构件(*service*)和连接子*connectors*(构件的协议，比如*SOAP*)、软件结构
- 类图、对象图
- 构件图

- 部署图(物理节点和节点之间的关系、物理模型)

- E-R图(概念模型)

- 结构图(描述程序调用结构)

  ------

  **部署图如下**

  ![image-20190916100335166](/Users/apple/Desktop/MarkDown%E7%AC%94%E8%AE%B0/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/image-20190916100335166.png)

  

***

#### 行为视图

- 活动图：在系统设计中，描述业务领域中的过程，角色之间的协作
- 协作图/序列图：二者取一即可，区别在于协作图以消息的形式描述对象之间的交互、序列图以时间的形式描述
- 决策图、表
- 状态转义图：状态和状态之间的转义，比如页面之间的跳转
- 形式化规范语言：需求中描述的前置、后置条件
- 伪代码：顺序、循环、选择和并发...





***

## 体系结构设计==方法==

### 结构化设计

**结构化设计中的主要内容**

- 数据流：输入-输出
- 控制流

使用伪码（Pseudo Code）描述算法，**算法**能够对数据进行计算，描述这个**过程**

**伪码描述算法如下**

![image-20190916102340135](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190916102340135.png)

![image-20190918144040805](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144040805.png)

***



![image-20190918144152538](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144152538.png)

该种数据流图用于描述模块与模块之间的调用的关系

**特点：**

画法比较==随意==，体现在层次图和网状图混搭使用。容易造成==**语义**上的不匹配==。



***

![image-20190918150944277](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918150944277.png)

***

上图出现的层次图，上层的叫扇入，下层的叫扇出。

扇入扇出的<u>模块数量划分应该遵守"7±2"原则</u>。





![image-20190918144243755](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144243755.png)



***

#### OOD

#### 系统设计过程

- 把分析模型划分为**子系统**

- 识别由问题域所决定的并发性：平台间并发，平台内**进程**、**线程**并发
- 把子系统分配给处理器和任务：**物理层**的设计
- ==设计用户界面==：和需求的原型设计不冲突不重复，原型体现的是<u>界面和流程</u>，设计阶段的用户界面设计需要产品经理（需要考虑**用户画像**等）组织的**专业**的美工人员、**UI设计师**操作。
- 选择实施数据管理的基本策略：数据怎么存放？放在那里？

- 识别全局资源和访问这些资源的控制机制：**安全性**

- 制定集成测试计划
- 制定详细设计阶段的计划 SPMP/DD，SCMP/DD，SVVP/DD，SQAP/DD
- 评审
  1. 体系结构设计文档和集成测试计划由 用户、开发者、管理层和质量保证人员进行正式评审
  2. SPMP/DD，SCMP/DD，SVVP/DD，SQAP/DD 由管理层和质量保
     证人员进行评审



***

#### 分布式计算环境

**LAMP技术基本架构如下**

![image-20190918144857530](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144857530.png)

 Linux+Apache+MySQL+PHP

**特点是**

- **免费开**源、社区生态**好**
- 适合构建组织内的轻量级应用
- 因为构建在一台服务器上，所以系统扩展较为麻烦。性能扩展和可维护性较**差**。



***

##### 可用性

**两个指标的计算公式定义和计算公式如下：**
$$
网站不可用时间 = 故障修复时间点-故障发现时间点
$$

$$
网站年度可用性指标=\frac{(1-网站不可用时间)}{年度总时间} ×100％
$$



***

##### 性能

![image-20190918151044724](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918151044724.png)

描述性能的时候需要严谨的**数据计算**和严格的**前置条件**(硬件...)



***

##### 并发数

![image-20190918151330187](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918151330187.png)

分别表示的含义是：

1. 已经**注册**的用户
2. **登录**在线的用户
3. **同一个操作同时发生**的数量



***

##### 吞吐量

**单位数据系统处理的请求的数量**

单位一般是TPS每秒事务数/HPS每秒HTTP请求数/QPS每秒查询书



***

##### 性能测试

![image-20190918153206170](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918153206170.png)

###### 服务器集群的演变

![image-20190918153404655](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918153404655.png)



一个服务器的情况下，为了性能，可以应用服务器和数据库服务器分开。



***

![image-20190918153449070](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918153449070.png)

为了提高查询的速度，可以建立分布式缓存服务器，将数据放入内存。某个时间段访问某个数据比较频繁时就可以将这些数据存入缓存服务器。

尚待解决的问题是数据库服务器中的数据和缓存中的数据==同步==的问题。

> 大数据处理中，spark就是典型的将数据存入内存，速度比hadoop更快



***

![image-20190918154016945](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154016945.png)

***

**服务器集群架构如上图**

多个服务器处理请求，至于怎么分发请求，可以使用下图

![image-20190918154122270](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154122270.png)

***

**==负载均衡器==**如上图

**具体的策略可以是**：

- 随机
- 轮询
- 基于资源：能者多劳
- 权重



***

当数据库称为服务器的瓶颈的时候，我们可以划分主从数据库服务器

![image-20190918154636266](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154636266.png)

将读数据和写数据分开为主从服务器，优化服务器的性能。

CDN的存在提高了性能和可靠性，可以通过镜像服务器读取跨区域的服务器的内容。

***

**分布式的文件和数据库系统**

适合大数据的存储。

> hadoop和spark的底层就是分布式的文件和数据库系统。

![image-20190918154912318](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154912318.png)

**分布式的文件和数据库系统架构如上**



非关系型数据库也有相应的服务集群

![image-20190918155137756](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155137756.png)

MongoDB也是典型的文档型数据库



****

应用拆分

![image-20190918155300635](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155300635.png)

将应用的不同功能分包，每个包都是一个集群，彼此之间互不影响。

***

将数据库的访问隔离开，访问不同的数据库可以使用不同的类

![image-20190918155643881](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155643881.png)

微服务的例子

![image-20190918155823501](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155823501.png)

各个服务器的监控、API是指REST API，对数据库的访问通过一个类似域名的地址来访问。

