

# 软件设计笔记第一讲

> @Date:2019年08月26日
>
> @Author:YeLihu
>
> @Email:87160265@qq.com

***

[TOC]



## 课程介绍

> 课程时间：2019-08-26

==Q：软件设计和程序设计有什么不一样？==

==Q：软件包含什么==

**和其他课程的关系**

1. 需求：**前导课程**
2. 数据库：
   1. 数据库的类型是什么？
   2. 数据库的数据量有多大？需不需要分库分表的操作？
   3. 数据的更新频率是多大？
   4. 范式/性能？
3. 测试：**测试是保证软件质量的==重要环节==**
   1. 测试用例怎么设计？
   2. **测试的依据是分析的文档**
4. 构造和演化：**软件设计的后续课程**
   1. 编码，<u>单元测试，集成测试和性能测试</u>形成了软件的构造
   2. 设计模式？
5. 软工综合实践：第七个学期
6. 毕设：第八个学期



***

## 体系结构设计概念

### 软件体系结构出现的原因

- 上个世纪90年代，网络的发展，==Web Server==的出现导致。

- 软件具有**抽象**的特点，不像建筑工程等，只需做好设计，画好图纸即可。

> **什么是Web Server**？
>
> Web服务器可以解析HTTP协议。当Web服务器接收到一个HTTP请求(request)，会返回一个HTTP响应(response)。
>
> 例如送回一个HTML页面。为了处理一个请求(request)，Web服务器可以响应(response)一个静态页面或图片，进行页面跳转(redirect)，或者把动态响应的产生委托给一些其它的程序例如JSP(JavaServer 
> Pages)脚本，servlets，ASP(Active Server Pages)脚本，服务器端(server-side)JavaScript，或者一些其它的服务器端(server-side)技术。

***

#### 软件危机

需求的时候讲过，软件危机发生的原因：<u>需求不明确，软件项目管理不当</u>、技术...

##### 原因

- 软件的规模越来越大，项目进度已经无法控制
- 成本(谁出钱？)
- 软件质量差

##### 如何解决

- 需求方面进行改革==(解决需求的问题)==
- 项目管理，引入体系结构==(解决规模的问题)==

> **维基百科**：[https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA](https://zh.wikipedia.org/wiki/软件危机)

***

### 体系结构的兴起

- 随着软件系统规模越来越复杂，整个系统的结构和规格说明显得越来越重要。
- 对于大规模的复杂软件系统来说，对**总体的系统结构**设计和规格说明比起**算法和数据结构**的选择==重要得多==。
- 对软件体系结构的研究将会成为提高软件生产率和解决软件**维护问题**的有效途径。(DevOPs、以产品管理为核心)
- 事实上，软件总是有体系结构的，**不存在没有体系结构的软件**。
- 软件体系结构虽起源于软件工程，但其形成同时借鉴了**计算机体系结构**和**网络体系结构**中很多宝贵的思想和方法，成为软件工程研究的重要分支



***

### 体系结构的定义

#### 从构成的角度

注重区分处理构件、数据构件和连接构件，这一方
法在其它的定义和方法中基本上得到保持

#### 从工程过程的角度

这一过程在的算法设计和数据结构设计之上

处理的是整体的结构，构件、协议...

> 爷问：什么是协议？
>
> 协议包含：
>
> - 数据格式
> - 数据顺序
>
> 一种关于内容和顺序的约定，比如我们要求数据接口的参数、返回值、取值范围等，这就是一个协议。

#### 从审视的视角

 体系结构是复杂的，我们怎么去观察体系结构呢？下面四个视角。

- 概念角度描述系统的==主要构件及它们之间的关系==；
- 模块角度包含功能分解与层次结构；
- 运行角度描述了一个系统的动态结构
- 代码角度描述了各种代码和库函数在开发环境中的组

#### 从重用的角度

代码重用的好处如下：

1. 提高效率
2. 节约时间（比如框架）。

软件体系结构级的重用意味着体系结构的决策能在具有相似需
求的多个系统中发生影响，这比代码级的重用要有更大的好处。

#### 从维护的角度

软件体系结构是一个程序／系统各构件的结构、它们之间的相互关系以及进行设计的原则和随时间演化的指导方针。

#### 从工程的作用

软件体系结构包括一个软件和系统构件、互联及约束的集合一个系统需求说明的集合





***

### 软件体系结构的意义

体系结构是风险承担者（Stick Holder）进行交流的手段

从对象的角度来看：软件 = 对象 + 消息

**软件体系结构，用户要参与评审(怎么参与评审？)**

- 软件体系结构代表了系统的公共的高层次的抽象
- 软件体系结构对项目最终的质量和使用有极大的影响



**软件体系结构的作用：**

1. 体系结构是早期设计决策的体现

2. 软件体系结构明确了对系统实现的约束条件

3. 软件体系结构影响了开发组织的组织结构

4. 软件体系结构制约着系统的质量属性

5. 通过研究软件体系结构可能预测软件的质量(预测每千行代码的数量...)

6. 软件体系结构使推理和控制更改更简单

7. 软件体系结构有助于循序渐进的原型设计(先做核心的功能)

8. 软件体系结构可以作为培训的基础(新的人员可以根据文档快速的了解)





***

### 发展史

![image-20190828155521755](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190828155521755.png)

### 描述和表示体系结构的构造

<u>描述体系结构的过程称为体系结构构造</u>

"==4+1=="模型包括

- 设计视图
- 进程视图
- 实现视图
- 部署视图
- 用例视图

IEEE于1995年成立了体系结构工作组，起草了体系结构描述框架标准IEEE P1471

> 这是一种严格的国际标准，不同于国际标准的还有组织标准和国家标准，行业标准和企业标准。比如TCP/IP和UML就是一种行业标准

### 分析、设计与验证

**验证**

<u>ATAM-Architecture Tradeoff Analysis Method</u>

上面这个是软件体系结构评审的标准。

### 基于体系结构的软件开发方法

引入体系结构之后，软件系统的开发过程变为==“问题定义—>软件需求—>软 件体系结构—>软件设计—>软件构造”== 

软件体系结构架起了软件需求与软件设计之间的一座桥梁 

在基于构件和基于体系结构的软件开发逐渐成为主流情况下，已经出现了基于==构件==的软件工程。 

> **什么是构件？**
>
> 构件类似于service，可以举例为第三方支付，地图等第三方接口。除了service，还可以通过网络协议等实现。



### 体系结构框架 in 特定领域

体系结构设计是可重用的，特定领域下，软件体系结构是相似的。

DSSA：面向某一个领域的体系结构。

***

### 本课程的体系结构

**定义和关键字**

- 软件体系结构：体系结构是一种构件的层次化结构，包含构件之间的交互方式、 

  构件使用的数据结构

- 构件：指==语义完整==、语法正确和有可重用价值的软件单元。比如属性要定义取值类型，范围等、方法要指明参数和功能。



***

### 什么是构件模型

面向构件的模型历史上有：CORBA,EJB（SUN公司的Enterprise Java Bean）,COM/COM+/DCOM。

但是他们彼此之间互不兼容，各家有各家的标准，所以并没有流行开来。他们被SOA取代。

#### 什么是SOA

> **SOA理解：**
>
> 把系统按照实际业务，拆分成独立部署的模块。
>
> 比如Web、Android、iOS三个端的网易云音乐都需要访问一个数据库来查询用户账号密码是否存在。
>
> 不使用SOA的思想，使用传统的解决方式是每个端都自己写一个查询的方法。
>
>  坏处是如果数据库变动，比如某一天username字段变成了xuehao（学号），那么三个端全部需要改各自的代码，并且三个段修改的逻辑和操作完全一样。
>
> 于是出现了这样的设计思想，搭建一个工程部署在一个服务器上，其余三个端（Web、Android、iOS）可以通过http或者基于socket的PRC调用来访问，获取JSON格式或者XML格式的数据。这个访问的端口暴露给这三个端，这种方式叫做"==服务=="。同理，其他场景的操作都可以这样形成服务。
>
> **优点是：**
>
> - 解耦
> - 当这个场景的业务突然出现高并发的时候，可以多提供几台服务器来提供服务。
> - 清楚的看到谁调用服务，调用热度…便于之后的优化
>
>  SOAP、REST、RPC就是根据这种设计模式构建出来的规范，其中SOAP通俗理解就是http+xml的形式，REST就是http+json的形式，RPC是基于socket的形式。CXF就是典型的SOAP/REST框架，dubbo就是典型的RPC框架，而SpringCloud就是遵守REST规范的生态系统。
>
> 上述文字参考和整理自CSDN一篇博文...

***

### 软件体系建模——"4+1"模型

**"4+1"模型-概述**

"==4+1=="模型包括

- 设计视图
- 进程视图
- 实现视图
- 部署视图
- 用例视图

#### 逻辑视图

![image-20190902110306909](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190902110306909.png)

OS/CPU/网络等等都与软件的架构息息相关。

#### 逻辑视图解析

与需求上相同的是，都是使用UML语言来描述，但是在设计中，不包括一些物理实体。

- 逻辑视图主要支持系统的功能需求，即系统提供给最终用户的服务。 
- 在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表 逻辑视图，用类图来描述逻辑视图 

#### 开发视图解析

开发人员(程序员)使用

描述一个类的名称方法属性等。

开发视图当中是分层描述的(controller、service、dao…...)

#### 进程视图描述

几个进程可能运行在不同的机器上。

比进程更小的单位是线程和协程，因为当前cpu是多核的，能够更好的提高并发的表现。

#### 部署视图/物理视图

描述软件和硬件的配合

为了满足软件对于硬件的需要：

- 软件需要多少带宽？(网络)
- cpu需要多少核心的？需不需要集群？
- ...

#### 用例视图("4+1"模型中的"1")

将需求中用例图的system打破，拆分和展开。 

### 体系结构设计过程

#### 目标

将逻辑模型转化为实现模型。

#### 实施和参与者

实施者是：==系统架构师==

- 开发者(程序员、测试人员…...)
- 用户代表
- 硬件/网络架构师
- 安全架构师/咨询师、 
- 操作人员 

#### 过程

#### 主要输出

主要输出有如下几个文档

- 体系结构设计文档 (ADD-Architectural Design Document); 
- 详细设计阶段的软件项目管理计划 (SPMP/DD);
- 详细设计阶段的软件配置管理计划 (SCMP/DD);
- 详细设计阶段的软件验证与确认计划 (SVVP/DD);
- 详细设计阶段的软件质量保证计划 (SQAP/DD);
- 集成测试计划 (SVVP/IT).
- 进度报告和配置状态审计报告 



***

#### 设计的基本原则

**基本原则如下，后附解析(加粗)：**

- 考虑多种设计方案：

  需要考虑==平衡折中==的方案(投资/时间/领域是否成熟/团队的能力)*

- 设计应该可跟踪到需求模型

  设计一定是基于需求而不是想象！==跟踪矩阵==可以很好的解决这个问题*

- 设计应尽可能地重用设计经验：

  *为了提高质量和效率，既然可以重用，说明有了先前经验，质量上可以保证，重用能够节省时间。类似于需求的重用（<u>概念模型可以重用,用户、功能...</u>），设计也可以有重用(==体系结构风格style==、==设计模式DP==)。*

- 软件的结构应与问题域的结构相近。

  *比如教务系统的设计上，用户角色和岗位的设置就要==尽可能的和现实一样==。*

- 设计模型应该符合统一规范。

  *不同岗位、前端后端，都需要遵循一定的规范。*

- 设计不是编码，编码也不是设计。

  *设计中的伪码比C/Java…编程语言更加抽象，并且注重逻辑。*

- 对设计模型进行质量评审，而不是事后进行修改。

  *找bug效率最高的方式、质量的保证是——==评审==。评审可以分为结对编程和<u>正式评审</u>，这个环节发生在正式提交编译之前。*



> **如何将人工智能运用到软件工程？**
>
> 自动编码、项目管理





***

#### 设计风格

***

##### 定义

- 描述**某一特定应用领域**中系统组织方式的**惯用模式**。 某一类特定的领域
- 体系结构风格定义了一个系统家族：即一个体系结构定义了：
  - **一个词汇表**：词汇表包含
    - **一些构件**：内存，数据库….
    - **<u>连接件类型</u>**：协议(HTTP/JDBC…)构件之间联系的方式。
  -  **一组约束**：这组约束指出系统 是如何将上面这些构件和连接件组合起来的。 
- 体系结构风格反映了领域中众多系统所共有的结构和语义特性，并指导 如何将各个模块和子系统有效地组织成一个完整的系统。 

***

##### 经典软件体系结构风格

- 数据流风格:批处理序列;**管道**/过滤器**例子：Linux和Unix的非交互式系统，一个个命令按照输入的顺序执行。**
- 调用/返回风格:主程序/子程序;面向对象风格;**分层结构**。**对象→方法**
- 仓库风格:==数据库系统==;超文本系统;黑板系统。

***

**上面三种结构风格优缺点整理如下：**

|      | 数据流风格                                                   | 面向对象的体系                           | 仓库风格                                     |
| ---- | ------------------------------------------------------------ | ---------------------------------------- | -------------------------------------------- |
| 优点 | 重用、维护、并发性支持、大数据处理(数据的去杂、过滤、去噪等…使用流的方式会更好) | 交互性强，复用性好                       | 数据和事务的处理(数据的管理：增、删、查、改) |
| 缺点 | 没有交互、设计复杂                                           | 必须知道谁(对象)提供服务(函数)，灵活性差 | 单一，优点也是缺点                           |



***

###### 管道和过滤器

![image-20190904152842976](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904152842976.png)

**管道和过滤器的优点**

适合大数据处理，数据的去杂去噪过滤等操作。

**管道和过滤器的缺点**

没有交互

***

###### 分层系统

> 计算机网络就是分层的体现，物理层/网络层/应用层/…...

**分层系统的优点**：

将大的系统降低复杂度。

可以协作、便于维护、便于重用。避免竞争。、

**分层系统的缺点**：

**实时性、性能要求较高的系统支持较差**

本来是直接简单的操作，现在需要在整个系统中层层传递，势必造成性能的下降，同时也加大的开发的复杂度。

***

###### 仓库系统

- 数据库
- 内存方式：Html5中的内存数据库、session、indexDB…...



***

###### C/S架构和三层C/S架构

**主要有三个组成部分：**

1. 数据库服务器
2. 客户应用程序
3. 网络

***

**CS发展历史**

![image-20190904154900108](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904154900108.png)

***

**C/S风格的优点**

- 数据管理和应用分开，安全性高。
- 数据的处理效率高，局域网内效果明显。
- 对于整个计算机系统的扩充较为灵活

***

**C/S风格的缺点**

- 开发成本较高
- 客户端设计复杂
- 移植性、可维护性较差
- 软件升级困难
- 新技术不能轻易应用

***

**三层CS架构——面向构件的软件开发**

解决CS架构的缺点，远程调用方法。这种过程属于实例与实例之间的调用。

出现了应用服务器、对应的软件体系结构是三次C/S风格

![image-20190904160424981](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904160424981.png)

***

![image-20190904160617897](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190904160617897.png)

***

**C/S结构的优点**

- 可维护（比如界面修改）、可升级(比如服务器扩容、改集群)
- 硬件上可以纵向升级(加内存...)
- 编程语言上自由选择，只要服从一定的协议即可。
- 数据展示层和数据层分开，保证了安全性。



**C/S结构的缺点**

- 通信效率不高(分层结构的通病，比如计算机网络7层/5层架构)
- 通信技术的选型(通信方法/通信频度/数据量)麻烦，设计和开发时间长。



> 2019年09月09日
>
> 爷问：**框架（Framework）**和**库（Library）**有什么区别
>
> **框架：**
>
> 调用我们写的callback，函数的参数往往可以是一个回调函数，需要我们自定义并传入。也就是说，我们的代码按照别人的规则去写，这里也有IOC（控制反转）的思想
>
> **库：**
>
> 单纯的被我们调用。
>
> 参考资料：https://blog.C/Sdn.net/weixin_41146340/article/details/79385244



***

###### B/S架构

B/S架构本质上还是C/S架构，只不过browser(浏览器）是一种特殊的client（客户端）。

三层BS架构图示如下：

**![image-20190909102716419](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909102716419.png)**



***

**B/S架构的优点：**

- 安装、维护、升级（运行时）方便（云服务使得租用服务器变得更加方便）
- 只要支持上层TCP/IP的协议，不同的服务器类型和底层网络技术都能支持网页浏览。

> 底层网络技术有哪些？
>
> 网络底层技术是指接入网络所必需、必要的、最基本需要满足的条件的技术。
> 网络底层技术包括
>
> 1. 以太网技术（局域网）
> 2. 其他局域网技术
> 3. 光纤分布式数据接口
> 4. 其他诸如路由器、MODE等数据交换及辅助技术



**B/S架构的缺点**

- **安全性（主机安全、网络安全、应用安全）不易控制**，因为建立在一个**开放的协议**之上。
- 数据查询速度较慢，**协议更多**，现在出现了一些在线处理数据的技术
- 数据动态交互性较差



***

**B/S架构与C/S架构的优缺点对比：**

| **C/S**            | B/S                |
| ------------------ | ------------------ |
| 应用部署在客户端上 | 应用部署在服务器上 |
| 不利于维护和升级   | 升级和维护方便     |





***

#### 接口定义语言

**CORBA定义：**

CORBA 通用对象请求代理体系结构 *(Common Object Request Broker Architecture)* 由OMG组织制定的一种标准面向对象应用程序**体系规范**。



**CORBA的特点：**

- 引入中间件作为事务代理，完成C端向S端提出的服务请求
- C端和S端完全分开
- 软总线机制，分布式系统中的任何一段不被编程语言限制，彼此之间只要符合接口规范定义即可通信。CORBA利用IDL*（Interface Defination Language）*统一地描述服务器，为C端提供了语言的独立性。
- 使用面向对象软件实现方法，内部完整封装，保留对象方法的对外接口。*CORBA*中的*IDL*接口定义语言用来描述接口而不涉及具体实现。

> 中间件：
>
> 中间件是一种系统软件和服务程序，实现两个不同的应用程序在不同的OS环境下，通过中间件可以交换信息；应用程序有能力能够运行在多平台(OS环境)

***

###### CORBA结构图

![image-20190909105622978](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909105622978.png)





***

#### 异构风格

同个系统下，有时面对来自不同环境的操作，以及不同的业务情况下会混合搭配使用不同的软件体系结构。是因为：

- 扬长避短
- 随着时间的改变，变动是绝对的
- 历史遗留代码，不再重写



##### 内外有别模型

![image-20190909110033888](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909110033888.png)



**解释：**

内部访问用C/S架构，外部访问用B/S架构

***

##### 查改有别模型

![image-20190909110205829](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909110205829.png)

**解释：**

查询数据用B/S架构，修改数据用C/S架构





***

### 面向过程的设计

#### 基本概念

##### 抽象

将事务内在、本质的东西集中**概括**，差异和细节。

- 高层抽象与问题域有关

比如校医院系统的人物抽象（血型、体重、病史...）和教务管理系统的人物抽象（学号、年级、挂科数...）是不一样的

- 底层抽象与计算有关

存储一系列同等类型的实例的集合。

***

##### 细化

<u>集中精力解决主要问题</u>，**推迟**对细节的考虑

**特点：**

特点逐渐增加，自顶向下的策略。

**Miller（7±2）法则：**

人只能把注意力集中在5-9个知识块之上。

**意思是：**类的方法或结构的层次我们都只能把它分为5-9个/层



***

#### 模块化设计

**整个系统分为若干模块**，每个模块实现一个功能，为了实现**==降低复杂问题的难度==**。

实践发现，问题分开解决比问题一起解决的复杂度小。但是模块数量多了之后，模块和模块之间的**通信接口的的成本会上升**，盲目增加模块数量是不理智的。



![image-20190909112504751](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190909112504751.png)



***

**模块化的好处**

**模块化的好处如下：**

- 可读性好*导致了第2点和第3点的产生*
- debug和测试容易
- 整体的可修改性优
- 人员分工方便、多人协作
- 代码重用性好



> 那么，模块化好不好的指标是什么？
>
> 模块独立性来衡量

***

#### 模块独立性

**模块的独立性要求模块必须**

- 联系最少
- 接口简单：参数数量小于等于三、 参数的类型尽可能的基本

**模块的独立性要求我们必须设计出高内聚低耦合的模块**



模块的独立性的衡量/组成包括模块的内聚和耦合

***

##### 模块的内聚

模块内部之间的联系越紧密，模块的独立性越高。

![image-20190911150342015](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190911150342015.png)

由图可见，**模块的独立性和内聚程度呈现正相关的关系**。



内聚包含以下七个部分

***

###### 逻辑性内聚

几个逻辑上相似的代码糅合在一起，使用一个标志(flag变量)去决定调用哪一个部分的代码。这样的内聚叫做逻辑性内聚。

**缺点**

- 不易修改
- 产生耦合
- 加载效率低

工厂类不属于这种内聚，工厂类



***

###### 偶然性内聚

将结构和功能相似的代码，合成一个模块。

这种内聚的等级最低，**特点如下：**

1. 内聚程度底下导致模块独立性差
2. 出错率最高



***

###### 时间性内聚

一个模块将需要在==同一时间完成的多种任务合并在一起执行==，这样的代码叫做时间性内聚。

比如在一个程序初始化<u>不仅</u>需要加载类库<u>还要</u>进行读取文件进行I/O等….，把上面这两种代码的执行**糅合**在一个模块中的这种内聚，就叫做时间性内聚。

<u>它和对象的生命周期（lifecycle，比如存在在安卓的activity里）的存在不属于一个性质，JVM里面引入生命周期机制为了GC（垃圾回收）收回对象占用的系统资源。</u>



***

###### 过程性内聚

这一个模块只是单纯的将==彼此之间有先后顺序、下层需要上层代码提供处理结果==的代码合成一个模块。

函数的递归当然不是过程性内聚。



***

###### 通信性内聚

这一个模块的相似点只是==共用相同的输入或者拥有相似的输出==。这样执行这些糅合在一起的代码的时候，传一个共用的参数即可。返回值也同理。



***

###### 顺序性内聚

假如这==一个程序分为几个部分==，每一个部分都围绕着一个功能服务，比如处理上传的文件或者处理字符串的格式等等…。并且==这些部分必须按照顺序来执行==，那么这样的内聚方式叫做顺序性内聚。

**顺序性内聚和时间性内聚的不同之处**

时间性内聚模块里的功能并不是围绕一个相同的功能服务的：

**设想一个场景**：

字符串解码之后需要把字符串交给别的函数形成txt文件输出。（这样的场景就是顺序性内聚）

但是时间性内聚，模块中的代码的场景各不相同。你可以做文件的IO，我可以初始化导入的类库….





***

###### 功能性内聚

==一整个模块的代码都是为了一个事务场景/具体功能服务的，模块之间的所有部分不能分割。==

比如Spring Framework自带封装好的StringUtils类，我们可以使用这个模块处理针对字符串的所有事务。

同理，大部分封装完备的一个util类都可以叫做功能性内聚。

**功能性内聚和顺序性内聚的区别**

功能性内聚为了完成一个完整的功能，顺序性内聚可以看做功能性内聚中的一部分。<u>(个人理解)</u>

功能性内聚内聚程度**最强**。



****

###### 参考：百度百科上的解释

内聚性是一种非量化的量测，可利用评量规准来确认待确认源代码的内聚性的分类。内聚性的分类如下，由低到高排列：

- 偶然内聚性（Coincidental cohesion，最低）偶然内聚性是指模块中的机能只是刚好放在一起，模块中各机能之间唯一的关系是其位在同一个模块中**（例如：“工具”模块）**。

> 这里和大爷矛盾，存疑，不清楚这个工具模块是不是util类

- 逻辑内聚性（Logical cohesion）逻辑内聚性是只要机能只要在逻辑上分为同一类，不论各机能的本质是否有很大差异，就将这些机能放在同一模块中（例如将所有的鼠标和键盘都放在输入处理副程序中）。
- 时间性内聚性（Temporal cohesion）时间性内聚性是指将相近时间点运行的程序，放在同一个模块中（例如在捕捉到一个异常后调用一函数，在函数中关闭已打开的文件、产生错误日志、并告知用户）。
- 程序内聚性（Procedural cohesion）程序内聚性是指依一组会依照固定顺序运行的程序放在同一个模块中（例如一个函数检查文件的权限，之后打开文件）。
- 联络内聚性（Communicational cohesion）联络内聚性是指模块中的机能因为处理相同的数据，因此放在同一个模块中（例如一个模块中的许多机能都访问同一个记录）。
- 依序内聚性（Sequential cohesion）依序内聚性是指模块中的各机能彼此的输入及输出数据相关，一模块的输出数据是另一个模块的输入，类似工厂的生产线（例如一个模块先读取文件中的数据，之后再处理数据）。
- 功能内聚性（Functional cohesion，最高）功能内聚性是指模块中的各机能是因为它们都对模块中单一明确定义的任务有贡献（例如XML字符串的词法分析）。



***

##### 模块的耦合

###### 非直接耦合

两个模块之间没有任何关系，他们之间通过**主函数调用**。

比如main函数调用函数func1和函数func2来分别完成计算1+1和在屏幕上画画的操作。



***

###### 数据耦合

模块之间通过**基本数据结构**来通信，在高级语言中属于**值传递**而不是引用。

比如 `return int/boolean  `



***

###### 特征耦合

两个模块之间传递的数据结果或者对象，也就是上面说的**引用传递**（地址传递）java中的对象就是地址传递。



**怎么体现增加的耦合性呢？**

*比如我想使用你传给我的一个object，我必须清楚这个对象的类型、属性、方法…..给我添加了"有义务去了解这个对象"的麻烦，降低了可理解性。*



***

###### 控制耦合

通过一个**flag**变量（**控制变量**）来调用另外一个模块

> 和逻辑性内聚是对应的

**怎么体现增加的耦合性呢？**

*相比上面的特征耦合*，我现在甚至需要知道你这个函数里面有什么内容了，我还得记住这个函数，什么变量能调用出什么效果来。



***

###### 外部耦合

一组模块访问一个**全局变量**



***

###### 公共耦合

一组模块访问一个公共数据结构

> c语言的结构体

**公共耦合会造成**

- 存取控制不方便
- 可维护性差
- 可理解性差，*需要"我"去搞懂哪些数据被哪些模块使用*



***

###### 内容耦合

当：

1. 一个模块可以**直接访问**另外一个模块内部
2. 一个模块通过**不正常入口**进入另外模块**内部**
3. 一个模块**多个入口**

这三种情况出现的时候，内容耦合产生。

> 举例：
> C语言的goto语句
>
> 汇编中的jump



这种耦合程度**最强**，维护起来最麻烦。



***

#### 软件设计模型的描述

描述方法可分为两类符号：

#### 结构视图

- 文本、**形式化语言（离散数学中的逻辑、集合、代数）**、构件(*service*)和连接子*connectors*(构件的协议，比如*SOAP*)、软件结构
- 类图、对象图
- 构件图

- 部署图(物理节点和节点之间的关系、物理模型)

- E-R图(概念模型)

- 结构图(描述程序调用结构)

  ------

  **部署图如下**

  ![image-20190916100335166](/Users/apple/Desktop/MarkDown%E7%AC%94%E8%AE%B0/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/image-20190916100335166.png)

  

***

#### 行为视图

- 活动图：在系统设计中，描述业务领域中的过程，角色之间的协作
- 协作图/序列图：二者取一即可，区别在于协作图以消息的形式描述对象之间的交互、序列图以时间的形式描述
- 决策图、表
- 状态转义图：状态和状态之间的转义，比如页面之间的跳转
- 形式化规范语言：需求中描述的前置、后置条件
- 伪代码：顺序、循环、选择和并发...





***

## 体系结构设计==方法==

### 结构化设计

**结构化设计中的主要内容**

- 数据流：输入-输出
- 控制流

使用伪码（Pseudo Code）描述算法，**算法**能够对数据进行计算，描述这个**过程**

**伪码描述算法如下**

![image-20190916102340135](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190916102340135.png)

![image-20190918144040805](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144040805.png)

***



![image-20190918144152538](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144152538.png)

该种数据流图用于描述模块与模块之间的调用的关系

**特点：**

画法比较==随意==，体现在层次图和网状图混搭使用。容易造成==**语义**上的不匹配==。



***

![image-20190918150944277](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918150944277.png)

***

上图出现的层次图，上层的叫扇入，下层的叫扇出。

扇入扇出的<u>模块数量划分应该遵守"7±2"原则</u>。





![image-20190918144243755](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144243755.png)



***

#### OOD

#### 系统设计过程

- 把分析模型划分为**子系统**

- 识别由问题域所决定的并发性：平台间并发，平台内**进程**、**线程**并发
- 把子系统分配给处理器和任务：**物理层**的设计
- ==设计用户界面==：和需求的原型设计不冲突不重复，原型体现的是<u>界面和流程</u>，设计阶段的用户界面设计需要产品经理（需要考虑**用户画像**等）组织的**专业**的美工人员、**UI设计师**操作。
- 选择实施数据管理的基本策略：数据怎么存放？放在那里？

- 识别全局资源和访问这些资源的控制机制：**安全性**

- 制定集成测试计划
- 制定详细设计阶段的计划 SPMP/DD，SCMP/DD，SVVP/DD，SQAP/DD
- 评审
  1. 体系结构设计文档和集成测试计划由 用户、开发者、管理层和质量保证人员进行正式评审
  2. SPMP/DD，SCMP/DD，SVVP/DD，SQAP/DD 由管理层和质量保
     证人员进行评审



***

#### 分布式计算环境

**LAMP技术基本架构如下**

![image-20190918144857530](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918144857530.png)

 Linux+Apache+MySQL+PHP

**特点是**

- **免费开**源、社区生态**好**
- 适合构建组织内的轻量级应用
- 因为构建在一台服务器上，所以系统扩展较为麻烦。性能扩展和可维护性较**差**。



***

##### 可用性

**两个指标的计算公式定义和计算公式如下：**
$$
网站不可用时间 = 故障修复时间点-故障发现时间点
$$

$$
网站年度可用性指标=\frac{(1-网站不可用时间)}{年度总时间} ×100％
$$



***

##### 性能

![image-20190918151044724](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918151044724.png)

描述性能的时候需要严谨的**数据计算**和严格的**前置条件**(硬件...)



***

##### 并发数

![image-20190918151330187](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918151330187.png)

分别表示的含义是：

1. 已经**注册**的用户
2. **登录**在线的用户
3. **同一个操作同时发生**的数量



***

##### 吞吐量

**单位数据系统处理的请求的数量**

单位一般是TPS每秒**事务**数/HPS每秒**HTTP请求**数/QPS每秒**查询**数



***

##### 性能测试

![image-20190918153206170](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918153206170.png)

##### 服务器集群的演变

![image-20190918153404655](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918153404655.png)



一个服务器的情况下，为了性能，可以应用服务器和数据库服务器分开。



***

![image-20190918153449070](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918153449070.png)

为了提高查询的速度，可以建立分布式缓存服务器，将数据放入内存。某个时间段访问某个数据比较频繁时就可以将这些数据存入缓存服务器。

尚待解决的问题是数据库服务器中的数据和缓存中的数据==同步==的问题。

> 大数据处理中，spark就是典型的将数据存入内存，速度比hadoop更快



***

**服务器集群架构**

这种集群架构可以将请求分发给各个应用服务器

![image-20190918154016945](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154016945.png)

***

**服务器集群架构如上图**

由于可以分发处理请求，**那么按照什么策略分发请求**？ 

![image-20190918154122270](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154122270.png)

***

**==负载均衡器==**如上图

**具体的策略可以是**：

- 随机
- 轮询
- 基于资源：能者多劳，比如cpu核心数多的优先分配
- 权重



***

当数据库称为服务器的瓶颈的时候，我们可以划分主从数据库服务器

![image-20190918154636266](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154636266.png)

将读数据和写数据分开为主从服务器，优化服务器的性能。

CDN的存在提高了性能和可靠性，可以通过镜像服务器读取跨区域的服务器的内容。

***

**分布式的文件和数据库系统**

适合大数据的存储。

> hadoop和spark的底层就是分布式的文件和数据库系统。

![image-20190918154912318](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918154912318.png)

**分布式的文件和数据库系统架构如上**



非关系型数据库也有相应的服务集群

![image-20190918155137756](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155137756.png)

MongoDB也是典型的文档型数据库



****

应用拆分

![image-20190918155300635](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155300635.png)

将应用的不同功能分包，每个包都是一个集群，彼此之间互不影响。

***

将数据库的访问隔离开，访问不同的数据库可以使用不同的类

![image-20190918155643881](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155643881.png)

**微服务**

![image-20190918155823501](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190918155823501.png)

各个服务器的监控、API是指REST API，对数据库的访问通过一个类似域名的地址来访问。



***

##### 总结

在定义子系统的时候，**需要遵循**

- 与架构师合作(比如安全架构师/网络架构师负责协议、防火墙、网络拓扑等工作)
- 良好的界面定义、要有边界概念
- 构件（Service）应该封装在子系统内
- 通信构件独立封装
- 子系统数量遵循"7±2"原则
- 子系统进一步分解减少复杂性，耦合性





***

#### 用户界面

主界面设计应该起到索引的作用，并且和字体、命名、色彩搭配息息相关。

命名不应该和技术层面的词汇相关。



**界面设计涉及到技术和艺术两种思维方式**

- 技术
- 艺术

技术往往是收敛的，艺术思维是开放的。



***

#### 数据管理

1. 数据库选型：关系？内存？主从数据库服务器？
2. 数据库的访问方式：前端直接访问？sql语句？RESTAPI



***

#### 类和对象的设计

如果一个类较为简单，只需要自己就能完成一些工作的时候，只需要详细设计即可。

如果这个类较为复杂，涉及到继承..就需要体系结构设计。





### 面向对象设计原则(SOLID)

内容如下：

- 单一职责原则：一个对象包含一个单一的职责
- 开闭原则：对扩展开放、对修改关闭。开闭原则的关键是抽象化
- 里式代换原则：使用父类类型定义对象，在运行的时候确定其子类类型并替换父类对象
  - 依赖反转原则：==开闭原则是目的，依赖反转是方法==：高层模块不应该依赖低层模块；抽象类和接口放在代码中，具体实现放在配置文件中。针对接口编程，针对抽象的类和接口去实例化一个类。通过这种方式使代码变得可维护性更好。
    - 依赖注入
      - 构造注入：构造函数注入
      - 设值注入：setter
      - 接口注入：持有接口的应用，比如UserService，他是这个实体的属性，本身是一个interface
- 接口隔离原则：一个角色一个接口，将客户端不需要的行为隐藏起来。满足单一职责的原则，满足高内聚的原则下，接口中的方法越少越好。对于客户端来说，只能让客户端知道该客户端使用的接口即可，其余全部隐藏。
- 合成复用原则：使用**组合**聚合的关系，少用继承



>  **为什么少用继承**
>
>  当两个类出现==泛化==，即父子类的时候，需要使用到继承，继承为了==实现复用==，但是耦合性很强。当两个类之间需要出现复用的时候，首选组合和聚合的方式，毕竟有比继承更好的选择。



**组合和聚合的区别？**

- 聚合：has-a关系，父类包含子类，子类可以独立于父类存在(实体通过带参构造方法让别人注入，当然，这个实体也可以有无参构造器 `this.students = students`;)
- 组合：part-of关系，父类拥有子类，子类不能独立于父类存在(在自己的方法里面new出来  `students = new HashSet<Student>();`)



**依赖反转的实现方式**

- 在XML等类似配置文件中注册这些bean，需要的时候实时读取。
- 工厂模式



**接口隔离实现方式**

1. 定义一个大接口
2. 定义n个抽象类，每个抽象类定义几个特定客户端专用的接口
3. 具体哪个客户端再继承对应的抽象类





***

**迪米特法则**

内容：一个实体尽可能少的和其他实体发生关系，避免其他实体修改给这个实体造成影响。

**陌生人**

对于这个法则来说，==除了==实体中：

- this对象
- 参数(对象类型)
- 成员属性(对象类型)
- 成员属性(集合类型、集合里的属性)
- 实体可以产生的对象

其他的实体都是"**陌生人"**，这些陌生人都是**不能直接通信**的。



**优点和缺点**

- 好处：
  - 狭义迪米特：松耦合高内聚
  - 广义迪米特：高复用、隐藏对象的信息
- 缺点：
  - 通信效率不高，和网络分层结构差不多、高度模块化的通病。



**实践方法论**

- 创建松耦合的类
- 访问权限限制
- 类型设计成不变类
- 对其他对象，少用new。



***

## 设计模式

软件设计模式来自于建筑的设计模式

人工智能来自于脑科学，认知科学，来自于对经验的思考。

经验+知识≈模式(解决问题的模式)

**模式的构成**

- context模式可适用的前提
- theme和problem，要解决的问题
- solution，解决方案
- *附加：应用的案例（大爷添加）*





***

### 模式的定义

重用已有解决方案，无需重复相同的工作。

==模式是**特定环境**中解决问题的一种方案。==

***

### 软件模式

1990年软件工程开始借鉴建筑设计模式的思想，最开始由*Gang of Four*提出23中软件开发中使用频率较高的几种设计模式。

为了统一面向对象方法在分析、设计和实现的鸿沟



软件模式是软件开发的总体指导思路和参照样板

软件模式可以认为是软件开发这一特定**问题**的  **解法的统一表示**

**软件模式包括**

- 架构模式
- 分析模式
- 过程模式
- 设计模式



***

### 设计模式发展

**设计模式应用在历史中广泛的应用在**

- JavaSE/EE开发
- MS的.net

***

### 设计模式分类

设计模式按照设计模式的目的可分为

- 创建型：创建对象
- 结构型：处理类和对象的组合
- 行为型：类和对象如何分配职责



![image-20190925150247008](/Users/apple/Desktop/MarkDown笔记/文章图片/image-20190925150247008.png)

**常见的设计模式**

- 工厂模式
- 单例模式，比如这个类是为了统一编号
- 观察者模式：分布式系统、订阅者模式来传送客户端和服务端之间的消息。
- ...



设计模式是成功的、能够实现可维护性复用的**设计方案**，避免重复性工作，设计高质量系统

**优点**

- 标准、通用
- 便于沟通
- 设计方案可修改性好
- 提高开发效率和质量
- 对于初学者来说：
  - 深入理解OO
  - 学会阅读类库源码
  - 提高软件设计水平



***

#### 工厂方法模式

**目标：实现开闭原则**

开闭原则的准则是：尽量不要修改，而是扩充

这种方法的具体实现就是==依赖反转原则==



***

##### 依赖反转原则

在研究工厂模式之前，我们 先谈谈 ==依赖倒置原则==

这个原则的基本原则如下：

==要依赖抽象，而不是具体类==



继续解释就是，不管是高层组件(接口)还是底层组件(具体实现类)，都应该依赖于抽象。

比如说一家商店的类是高层，那么商店里的薯片就是低层组件。Factory是高层，product就是低层组件

而我们的商店，或者工厂factory都依赖于下面的这些低层组件。



但是 ==依赖倒置原则==告诉我们，不应该依赖具体实现类，而是抽象类。



**那我们到底怎么做？**

###### 倒置我们的思考模式

传统的思考方式都是自顶向下的，从商店开始思考。

现在我们需要这样思考：

1. 首先我要开一家有达利园、上好佳、乐事薯片的商店。
2. 上面几个品牌的产品都可以归类于薯片这个抽象类。
3. 已经有薯片这个抽象了，现在就可以开始开商店了。



###### 依赖反转行为准则

- 不用`new`，使用new就造成了持有具体类的引用
- 不继承具体类，继承自抽象和接口
- 不`@override`父类已经实现的方法



###### 场景举例

就拿上面的薯片为例，薯片有很多种类，比如：

- 乐事薯片
- 上好佳
- 达利园
- ...

我们可以设计一个抽象的产品类叫做 薯片 ，上面几种具体薯片继承这个薯片抽象类。

那么我们可以在商店这个类里面持有薯片这个抽象类，同时我们的上好佳薯片等具体实现的薯片类也依赖了这个抽象。

根据 *Header First 设计模式* 书里面的意思来说，这叫做：

高层和低层模块都在依赖这个抽象

- 对于上好佳来说，薯片是高层抽象，上好佳依赖了高层抽象
- 对于商店来说，薯片是低层抽象，商店依赖了低层抽象







------

##### 举一反三

让我们继续举例子，从产品和工厂两个角度来思考



###### 我们的产品

加入我现在要开早餐连锁店。按照上面的 ==依赖反转原则==

我先思考有什么早餐，我可以有：

- 类似肯德基的西式早餐，早上可以吃一个汉堡或者帕尼尼
- 类似永和豆浆的中式早餐，早上可以吃一个扬州炒饭或者包子



**上面这两个早餐要抽象在一个抽象类里面**

叫做早餐，我们让具体早餐继承他，这个早餐有一个早餐种类的属性和一堆对早餐售卖的方法：

- 属性
  - bfKind：早餐种类
- 方法
  - prepare：准备制作
  - pay：收钱
  - box：打包



**有了上面两个对于产品的思考，到这里我们可以给出代码了**

这里包子类作为中式早餐，汉堡作为西式早餐。

包子类：

```java
public class Baozi extends Breakfast{
    public Baozi() {
        bfKind = "中式早餐，包子很好吃！";
    }
}
```

汉堡类：

```java
public class Hanbao extends Breakfast{
    public Hanbao(){
        bfKind = "西式早餐，汉堡现在只要18元！";
    }
}
```

他们的父类——早餐类：

```java
public abstract class Breakfast {

    String bfKind;

    void prepare(){
        System.out.println("正在制作早餐，请稍等");
    }

    void pay(){
        System.out.println("收钱中，请付款");
    }

    void box(){
        System.out.println("收款成功！立即为您打包！");
    }

    public String getBfKind() {
        return bfKind;
    }

    public void setBfKind(String bfKind) {
        this.bfKind = bfKind;
    }
}
```



------

###### 我们的商店



**既然有了产品，我们可以现在思考如何开店了，我们可以：**

- 开一家店，这些店所有类型的都买，即卖中式又买西式，即卖汉堡又卖包子
- 开多家店，中式早餐店开在杭州，西式早餐店开在LA。==因地制宜==。



**毫无疑问，我们肯定选择后一种开店方式，好处我都高亮标出来了**

那么，我们的包子就要在中餐厅买，汉堡就要在西餐厅买。我给这俩餐厅起个名字，叫做：

- 永和早餐店
- KFC早餐店

这俩是具体实现类，在这个店里我们可以按照给定的类型，做出想要的西餐早餐或者中餐早餐。我们用一个if分支就可以解决这个问题。**比如：**

```java
if(type.equals("汉堡")){
    return new Hanbao();
}else if(type.equals("帕尼尼")){
    return new Panini();
}else{
    return null;
}
```



按照具体类抽象的做法，仿照着上好佳薯片—薯片的例子，我们将这俩店抽象为一个早餐店类，这个类将是此次代码中最高抽象层。

<u>商店在这里对应着工厂模式的工厂</u>，**商店这个抽象类有两个特点：**

- 实现 操作 产品的方法，但是不实现 工厂 的方法：也就是说，商店里面的方法负责将早餐准备，收钱，打包...但是具体生产什么类型的早餐，由什么早餐店生产，他并不详细制定。
- 所有的工厂实现类必须实现上面一条工厂抽象类不详细制定方案的方法：也就是说，中式早餐店，西式早餐店，我都必须实现工厂指定的方法，那就是返回你这个早餐店生产的早餐。



**上面的字很多，直接给个代码说明：**

```java
public abstract class BreakfastStore {

    public Breakfast orderBreakfast(String type){
        Breakfast bf;
        bf = cookBreakfaster(type);
        bf.prepare();
        bf.pay();
        bf.box();

        return bf;
    }

    protected abstract Breakfast cookBreakfaster(String type);

}
```



**上面可见：**

public Breakfast orderBreakfast(String type)这个方法是具体实现了的，我们可以理解为，所有的早餐店都会有店员来准备、收钱、打包…干这些活。

但是protected abstract Breakfast cookBreakfaster(String type)这个方法就不一样了，他需要子类去实现。也就是KFC或者永和早餐店去返回你们的汉堡或者包子给我。



**接下来，贴上永和早餐店和KFC早餐店的实现代码：**

KFC早餐店类：

```java
public class KfcBreakfastStore extends BreakfastStore{

    @Override
    protected Breakfast cookBreakfaster(String type) {
        if(type.equals("hanbao")){
            return new Hanbao();
        }else {
            return null;
        }
    }
}
```

永和早餐店类：

```java
public class YongHeBreakfastStore extends BreakfastStore{

    @Override
    protected Breakfast cookBreakfaster(String type) {
        if(type.equals("baozi")){
            return new Baozi();
        }else {
            return null;
        }
    }
}
```



**有了具体早餐店的代码，可以来验证一下，上面关于工厂类的实现或者不实现的要求，是不是都满足？**

> 是的！



**整个代码的结构如下**

![image-20190929140350569](/Users/apple/Desktop/MarkDown%E7%AC%94%E8%AE%B0/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/image-20190929140350569.png)

***

##### 好处

- 灵活易修改
- 提高开发效率





***

#### 装饰模式



















